Require Import MetaProp.
Require Import SyntaxProp.
Require Import DynamicProp.
Require Import TypesProp.
Require Import WellFormednessProp.
Require Import Shared.

Hint Constructors is_econtext.
Hint Constructors disjointLocks.

Ltac name_step :=
  let Hstep := fresh "Hstep" in
  match goal with
    | H: step _ _ _ |- _ => rename H into Hstep
    | _ : _ |- _ => idtac
  end.

Ltac inv_step :=
  match goal with
    | H: step _ _ _ |- _ => inv H; name_step
    | _ : _ |- _ => idtac
  end.

Ltac trivial_step_case := abstract(inv_step; try(malformed_context); eauto).

Lemma stepCannotSteal :
  forall P H H' V V' n n' T1 T1' T2,
    wfLocking H T1 ->
    wfLocking H T2 ->
    disjointLocks T1 T2 ->
    P / (H, V, n, T1) ==> (H', V', n', T1') ->
    disjointLocks T1' T2.
Proof with eauto.
  introv wfL1 wfL2 Hdisj Hstep.
  gen T1'.
  induction T1; intros.
  + inv Hstep.
  + gen T1'.
    inverts Hdisj as Hdisj1 Hdisj2.
    expr_cases (induction e) Case; intros; simpls;
    try(trivial_step_case).
    - Case "ECall".
      apply wfLocking_econtext in wfL1...
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
    - Case "EUpdate".
      apply wfLocking_econtext in wfL1...
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
    - Case "ELet".
      apply wfLocking_econtext with (ctx := ctx_let s e2) in wfL1...
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe1 in Hstep as []...
    - Case "ECast".
     apply wfLocking_econtext in wfL1...
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
    - Case "EPar".
      inv_step; try(malformed_context)...
      econstructor; simpl...
      * introv HIn. apply in_app_or in HIn as []...
      * introv HIn. apply not_in_app...
    - Case "ELock".
      inv_step; try(malformed_context)...
      constructor.
      * introv HIn. simpls. inv HIn...
        intros contra.
        eapply wfHeldLocks_taken in contra...
        congruence.
        apply wfLocking_wfHeldLocks...
      * introv HIn. intros contra.
        {inv contra.
         + eapply wfHeldLocks_taken in HIn...
           congruence.
           apply wfLocking_wfHeldLocks...
         + apply Hdisj1 in HIn...
        }
    - Case "ELocked".
      apply wfLocking_econtext in wfL1...
      inv_step; try(malformed_context); try(inv_eq)...
      * econstructor; simpl.
        introv HIn.
        apply in_app_or in HIn as []...
        introv HIn. apply not_in_app...
      * apply IHe in Hstep as []...
      * {constructor; simpl.
         + introv HIn. apply remove_in in HIn...
         + introv HIn. apply remove_not_in...
        }
  + apply disjointLocks_async in Hdisj as (Hdisj1 & Hdisj2 & Hdisj3).
    inv wfL1. inv Hdisj1. inv_step;
      try(apply disjointLocks_async);
      try(apply disjointLocks_leftmost)...
Qed.

Hint Constructors wfLocking.

Lemma wfLocking_async_preservation :
  forall P Gamma H H' V V' n n' T1 T1' T2 t,
    wfConfiguration P Gamma (H, V, n, T1) t ->
    wfLocking H T2 ->
    disjointLocks T1 T2 ->
    P / (H, V, n, T1) ==> (H', V', n', T1') ->
    wfLocking H' T2.
Proof with eauto using wfLocking_heapExtend, wfLocking_heapUpdate.
  introv wfCfg wfL2 Hdisj Hstep.
  assert(wfLs2: wfHeldLocks H (heldLocks T2))
    by eauto using wfLocking_wfHeldLocks.
  inverts wfLs2 as wfLs2.
  rewrite Forall_forall in wfLs2.
  inverts wfCfg as Hlt wfH wfV wfT wfL.
  inverts Hdisj as Hdisj1 Hdisj2.
  gen T1' t.
  induction T1; intros.
  + inv_step.
  + inverts wfT as Hfree hasType.
    gen T1'. hasType_cases (induction hasType) Case;
      intros; simpls;
      try(destruct_var; try(congruence));
      try(trivial_step_case).
    - Case "T_New".
      inv_step; try(malformed_context)...
    - Case "T_Call".
      inv_step; try(malformed_context)...
      apply wfLocking_econtext in wfL...
      inv_eq. apply IHhasType in Hstep...
    - Case "T_Update".
      inv_step; try(malformed_context)...
      apply wfLocking_econtext in wfL...
      inv_eq. apply IHhasType2 in Hstep...
      eapply wfLocking_heapUpdate...
      introv HIn. apply wfLs2 in HIn...
      inv HIn... rewrite_and_invert.
    - Case "T_Let".
      inv_step; try(malformed_context)...
      apply wfLocking_econtext with (ctx := ctx_let x body) in wfL...
      apply app_eq_nil in Hfree as [].
      inv_eq. apply IHhasType1 in Hstep...
    - Case "T_Cast".
      inv_step; try(malformed_context)...
      apply wfLocking_econtext in wfL...
      inv_eq. apply IHhasType in Hstep...
    - Case "T_Lock".
      inv_step; try(malformed_context)...
    - Case "T_Locked".
      apply wfLocking_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq)...
      eapply wfLocking_heapUpdate...
      introv HIn.
      apply Hdisj1 in HIn... inv HIn.
  + inverts wfT.
    inverts wfL.
    inv_step...
    - eapply IHT1_1; simpls...
      * introv HIn.
        apply Hdisj1...
        apply in_or_app...
      * introv HIn.
        apply Hdisj2 in HIn.
        apply not_in_app in HIn as []...
    - eapply IHT1_2; simpls...
      * introv HIn.
        apply Hdisj1...
        apply in_or_app...
      * introv HIn.
        apply Hdisj2 in HIn.
        apply not_in_app in HIn as []...
Qed.

Lemma spawn_no_locks :
  forall P Gamma e t H V n Ls e1 e2 e3,
    P; Gamma |- e \in t ->
    P / (H, V, n, T_Thread Ls e) ==>
      (H, V, n, T_Async (T_Thread Ls e1) (T_Thread nil e2) e3) ->
    no_locks e1 /\ no_locks e2.
Proof with eauto.
  introv hasType Hstep.
  gen e1 e2 e3.
  hasType_cases (induction hasType) Case; intros;
  inv_step; try(malformed_context); try(inv_eq)...
Qed.

Lemma spawn_locks :
  forall P Gamma e t H V n Ls e1 e2 e3,
    P; Gamma |- e \in t ->
    P / (H, V, n, T_Thread Ls e) ==>
      (H, V, n, T_Async (T_Thread Ls e1) (T_Thread nil e2) e3) ->
    locks e = locks e3.
Proof with eauto.
  introv hasType Hstep.
  gen e1 e2 e3.
  hasType_cases (induction hasType) Case; intros;
  try(solve[inv_step; malformed_context; simpls; inv_eq; eauto]).
  + Case "T_Let".
    inv_step; try(malformed_context); simpls...
    inv_eq. apply IHhasType1 in Hstep...
    inverts H0 as no_locks. rewrite no_locks.
    repeat rewrite app_nil_r...
  + Case "T_Par".
    inv_step; try(malformed_context)...
    simpls. inverts H1 as no_locks1.
    inverts H2 as no_locks2. inverts H3 as no_locks3.
    rewrite no_locks1. rewrite no_locks2. rewrite no_locks3...
  + Case "T_Locked".
    inv_step; try(malformed_context)...
    inv_eq. simpls. apply IHhasType2 in Hstep...
    inverts Hstep as Hlocks.
    rewrite Hlocks...
Qed.

Lemma noLostLocks :
  forall P Gamma l H H' V V' n n' T T' t,
    In l (leftmost_locks T) ->
    ~ In l (t_locks T) ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    In l (leftmost_locks T').
Proof with eauto.
  introv HIn HnIn wfCfg Hstep.
  gen T' t. induction T; intros.
  + inv_step.
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfL.
    inverts wfT as Hfree hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros;
    try(trivial_step_case).
    - Case "T_Call".
      inv_step; try(malformed_context)...
      inv_eq; simpl...
      inv Hfree. destruct_var; try(congruence).
      apply wfLocks_econtext in wfL...
      eapply IHhasType in Hstep...
    - Case "T_Update".
      inv_step; try(malformed_context)...
      inv_eq; simpl...
      inv Hfree. destruct_var; try(congruence).
      apply wfLocks_econtext in wfL...
      eapply IHhasType2 in Hstep...
    - Case "T_Let".
      inv_step; try(malformed_context)...
      inv_eq; simpls...
      inv Hfree. apply app_eq_nil in H2 as [].
      apply wfLocks_econtext with (ctx := ctx_let x body) in wfL...
      apply not_in_app in HnIn as [].
      eapply IHhasType1 in Hstep...
    - Case "T_Cast".
      inv_step; try(malformed_context)...
      inv_eq; simpls...
      inv Hfree.
      apply wfLocks_econtext in wfL...
      eapply IHhasType in Hstep...
    - Case "T_Lock".
      inv_step; try(malformed_context)...
      simpls...
    - Case "T_Locked".
      inv_step; try(malformed_context); simpls...
      * inv_eq.
        inv Hfree.
        apply wfLocks_econtext in wfL...
        eapply IHhasType2 in Hstep...
      * clear IHhasType1. clear IHhasType2.
        assert (l1 <> l)...
        apply remove_in_neq...
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree hasType wfT1 wfT2.
    inverts wfL as wfL HWdisj Hdisj wfL1 wfL2.
    inv_step...
    simpls...
    eapply IHT1 in Hstep...
    apply not_in_app in HnIn as []...
Qed.

Lemma noDuplicatedLocks :
  forall P t' Gamma l H H' V V' n n' T T' t c F,
    wfProgram P t' ->
    heapLookup H l = Some (c, F, LLocked) ->
    ~ In l (t_locks T) ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    ~ In l (t_locks T').
Proof with eauto.
  introv wfP Hlookup HnIn wfCfg Hstep.
  gen T' t. induction T; intros.
  + inv_step.
  + rename l0 into Ls.
    inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfL.
    inverts wfT as Hfree hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros;
    try(trivial_step_case).
    - Case "T_Call".
      inv Hfree. destruct_var; try(congruence).
      apply wfLocks_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType in Hstep...
      * eapply IHhasType in Hstep...
      * rewrite <- locks_subst. rewrite <- locks_subst.
        eapply wfProgram_wfMethodDecl in H19...
        inv H19. apply locks_static in H13. rewrite H13.
        contra...
    - Case "T_Update".
      inv Hfree. destruct_var; try(congruence).
      apply wfLocks_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType2 in Hstep...
      * eapply IHhasType2 in Hstep...
    - Case "T_Let".
      inv Hfree.
      apply wfLocks_econtext with (ctx := ctx_let x body) in wfL...
      inv H0.
      apply not_in_app in HnIn as [].
      apply app_eq_nil in H2 as [].
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType1 in Hstep...
        rewrite H3. rewrite app_nil_r...
      * eapply IHhasType1 in Hstep...
        rewrite H3. rewrite app_nil_r...
      * rewrite <- locks_subst. rewrite H3.
        contra...
    - Case "T_Cast".
      inv Hfree.
      apply wfLocks_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType in Hstep...
      * eapply IHhasType in Hstep...
    - Case "T_Lock".
      inv_step; try(malformed_context)...
      clears IHhasType1 IHhasType2.
      simpls... contra...
      rewrite_and_invert.
    - Case "T_Locked".
      inv Hfree.
      apply wfLocks_econtext in wfL...
      inv_step; try(malformed_context); try(inv_eq); simpls...
      * eapply IHhasType2 in Hstep...
        simpls. apply not_in_app in Hstep as [].
        apply not_in_app in H0 as [].
        apply not_in_app.
        split...
        apply not_in_app.
        split...
        contra...
      * eapply IHhasType2 in Hstep...
        contra...
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree hasType wfT1 wfT2.
    inverts wfL as wfL HWdisj Hdisj wfL1 wfL2.
    inv_step...
    - simpls...
      apply not_in_app in HnIn as []...
      apply not_in_app...
    - simpls...
      apply not_in_app in HnIn as []...
      apply not_in_app...
      split...
      apply not_in_app in H1 as []...
      apply not_in_app...
    - simpls.
      apply not_in_app in HnIn as [_ HnIn'].
      apply not_in_app in HnIn' as []...
Qed.

Ltac wfLocking_async_tactic :=
  match goal with
    [H1 : wfLocks _ ?e3, H2 : wfLocking _ (T_Thread _ ?e1) |- wfLocking _ (T_Async (T_Thread _ ?e1) _ _)] =>
    inv H1; inv H2; eauto
  end.

Ltac wfLocking_context_tactic :=
  match goal with
    [H : wfLocks _ ?e |- context[?e]] =>
    inv H; eauto
  end.

Hint Extern 1 => wfLocking_async_tactic 1.
Hint Extern 1 => wfLocking_context_tactic 1.

Theorem wfLocking_preservation :
  forall P t' Gamma H H' V V' n n' T T' t,
    wfProgram P t' ->
    wfConfiguration P Gamma (H, V, n, T) t ->
    P / (H, V, n, T) ==> (H', V', n', T') ->
    wfLocking H' T'.
Proof with eauto using wfLocking_heapExtend.
  introv wfP wfCfg Hstep.
  gen H' V' n' T' t.
  induction T; intros.
  + (* EXN does not step *)
    inv_step.
  + rename l into Ls.
    inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfL as wfLs Hdup wfL.
    inversion wfL.
    inverts wfT as Hfree hasType.
    gen T'.
    hasType_cases (induction hasType) Case; intros; simpls;
    assert(Hmono: n <= n') by eauto using step_n_monotonic;
    try(trivial_step_case).
    - Case "T_New".
      abstract(inv_step; try(malformed_context); eauto using wfLocking_heapExtend).
    - Case "T_Call".
      destruct_var; try(congruence).
      inv_step; try(malformed_context); unfold_ctx...
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep; simpls...
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep...
      * clear IHhasType.
        apply wfLocking_subst. apply wfLocking_subst.
        apply wfLocking_static...
        assert (wfMtd: wfMethodDecl P c (Method m (y0, t0) t'0 body)) by eauto using wfProgram_wfMethodDecl.
        inv wfMtd...
    - Case "T_Update".
      destruct_var; try(congruence).
      inv_step; try(malformed_context); unfold_ctx...
      * inv_eq. apply IHhasType2 in Hstep...
        inv Hstep...
      * inv_eq. apply IHhasType2 in Hstep...
        inv Hstep...
      * eapply wfLocking_heapUpdate; simpls...
        introv HIn. eapply wfHeldLocks_taken...
    - Case "T_Let".
      apply app_eq_nil in Hfree as [].
      apply wfLocks_econtext with (ctx := ctx_let x body) in wfL...
      inv_step; try(malformed_context); unfold_ctx...
      * inv_eq.
        inv wfL.
        apply IHhasType1 in Hstep...
        inv Hstep...
        inv H2.
        inv H13.
        {econstructor...
         + econstructor; simpl...
           - rewrite H7.
             rewrite app_nil_r...
           - rewrite H7.
             rewrite app_nil_r...
         + introv HIn. simpls.
           apply in_app_or in HIn.
           inv HIn...
           rewrite H7 in H2. contradiction.
         + econstructor; simpls...
           rewrite H7...
           rewrite H7...
         + crush.
        }
      * inv_eq.
        inv wfL.
        inv H3.
        apply IHhasType1 in Hstep...
        inv Hstep...
        inv H2.
        inv H11.
        {econstructor...
         econstructor; simpl...
         rewrite H7.
         rewrite app_nil_r...
         rewrite H7.
         rewrite app_nil_r...
        }
      * apply wfLocking_subst...
    - Case "T_Cast".
      inv_step; try(malformed_context); unfold_ctx...
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep...
      * inv_eq. apply IHhasType in Hstep...
        inv Hstep...
    - Case "T_Par".
      inv_step; try(malformed_context)...
      clears IHhasType1 IHhasType2 IHhasType3.
      inv H3. inv H4. inv H5.
      econstructor...
      * econstructor; simpl; rewrite H4...
        introv contra. inv contra.
      * rewrite H4. introv contra. inv contra.
      * econstructor...
        simpl; rewrite H6...
        simpl; rewrite H6...
      * econstructor...
        econstructor; simpl; rewrite H6...
        introv contra. inv contra.
      * econstructor; simpl; rewrite H6...
        econstructor; simpl; rewrite H3...
    - Case "T_Lock".
      inv_step; try(malformed_context)...
      inv H2.
      econstructor...
      * {apply wfHeldLocks_cons.
         + eapply wfHeldLocks_heapUpdate...
         + econstructor...
           rewrite lookup_heapUpdate_eq...
           apply heapLookup_lt...
        }
      * econstructor; simpl...
        introv HIn. inv HIn...
    - Case "T_Locked".
      inverts H1.
      assert (wfL': wfLocks Ls e) by eauto using wfLocks_econtext.
      inv_step; try(malformed_context)...
      * inv_eq.
        assert(Hno_locks: no_locks e1 /\ no_locks e2)
          by eauto using spawn_no_locks.
        assert(locks (ELocked l e) = locks (ELocked l e3))
          by (eapply spawn_locks; eauto).
        inverts Hno_locks as no_locks1 no_locks2.
        apply IHhasType2 in Hstep...
        inv Hstep.
        assert(locks (ELocked l e) = locks (ELocked l e3))
          by eauto using spawn_locks.
        {econstructor...
         + simpls. econstructor...
           - introv HIn. inv HIn...
             inv H1...
             rewrite <- H11 in H2...
           - simpl. inv_eq.
         + introv HIn. simpls.
           inv HIn...
           inv no_locks1... rewrite H3...
        }
      * inv_eq.
        assert(HIn': In l Ls')
          by (eapply noLostLocks in Hstep; try(econstructor); eauto).
        assert(HnIn': ~In l (locks e')).
          inv wfL. assert (In l Ls)...
          inv wfLs. rewrite Forall_forall in H6.
          apply H6 in H3. inv H3...
          eapply noDuplicatedLocks in Hstep...
          econstructor...
          econstructor...
          econstructor...
          rewrite Forall_forall...
        apply IHhasType2 in Hstep...
        inv Hstep.
        inv H7.
        inv H3.
        econstructor; simpls...
        econstructor; simpls...
        introv HIn.
        inv HIn...
      * clear IHhasType1. clear IHhasType2.
        {econstructor.
         + econstructor.
           rewrite Forall_forall.
           introv HIn.
           assert (Hneq: l <> x).
             intros contra; subst.
             eapply remove_in_eq in HIn...
           assert(wfLs': wfHeldLocks H (remove id_eq_dec l Ls))
             by eauto using wfHeldLocks_remove.
           inverts wfLs' as wfLs'.
           rewrite Forall_forall in wfLs'.
           apply wfLs' in HIn.
           inv HIn.
           econstructor...
           rewrite lookup_heapUpdate_neq...
         + apply remove_NoDup...
         + econstructor; simpls...
           introv contra. inv contra.
        }
  + inverts wfCfg as Hlt wfH wfV wfT wfL.
    inverts wfT as Hfree hasType wfT1 wfT2.
    inverts wfL as wfL HWdisj Hdisj wfL1 wfL2.
    inv_step...
    - assert (Hdisj': disjointLocks T1' T2)
       by (eapply stepCannotSteal in Hstep; eauto).
      assert (wfLocking H' T2).
        eapply wfLocking_async_preservation with (T1 := T1)...
      assert(wfCfg1: wfConfiguration P Gamma (H, V, n, T1) t1)...
      pose proof (IHT1 _ _ _ _ Hstep t1 wfCfg1) as IH.
      inv wfL.
      econstructor...
      * econstructor...
        introv HIn. eapply noLostLocks...
      * introv HIn.
        assert (~In L (t_locks T1))...
        apply H1 in HIn. assert (wfLs: wfHeldLocks H (leftmost_locks T1)) by eauto using wfHeldLocks_leftmost.
        inverts wfLs as wfLs. rewrite Forall_forall in wfLs. apply wfLs in HIn.
        inv HIn.
        eapply noDuplicatedLocks...
    - assert (Hdisj': disjointLocks T1 T2')
        by (eapply stepCannotSteal in Hstep;
            eauto using disjointLocks_commutative).
      assert (wfLocking H' T1).
        eapply wfLocking_async_preservation with (T1 := T2)...
        apply disjointLocks_commutative...
      assert(wfCfg2: wfConfiguration P Gamma (H, V, n, T2) t2)...
    - inv wfL1...
    - econstructor...
      eapply wfHeldLocks_leftmost...
    - econstructor...
      eapply wfHeldLocks_leftmost...
Qed.
